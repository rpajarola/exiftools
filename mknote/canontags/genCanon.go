// +build ignore
// This program generates canonAutoTags.go. It can be invoked by running
// go generate

package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"regexp"
	"strings"
	"time"
	"unicode"
)

// Based on ExifTool by Phil Harvey and Contributers
/// https://raw.githubusercontent.com/exiftool/exiftool/master/lib/Image/ExifTool/Canon.pm

const (
	fileName = "canonAutoTags.go"
	canonURL = "https://raw.githubusercontent.com/exiftool/exiftool/master/lib/Image/ExifTool/Canon.pm"
)

func FetchCanonTags() {
	resp, err := http.Get(canonURL)
	if err != nil {
		fmt.Printf("%s", err)
	}

	defer resp.Body.Close()
}

func main() {
	start := time.Now()
	dat, err := ioutil.ReadFile("Canon.pm")
	if err != nil {
		panic(err)
	}
	lens := ExtractCanonLensTypes(string(dat))
	models := ExtractCanonModelIDs(string(dat))

	out := fmt.Sprintln("package canontags")
	out += fmt.Sprintln("\nimport \"github.com/rpajarola/exiftools/models\"")
	out += fmt.Sprintf("\n//// Autogenerated file on %d %s, %d\n", start.Day(), start.Month(), start.Year())
	out += fmt.Sprintf("// Extracted from: %s\n", canonURL)
	out += fmt.Sprintln("// Based on ExifTool by Evan Oberholster (https://github.com/evanoberholster/exiftools)\n\n")
	out += fmt.Sprintln("// Based on ExifTool by Phil Harvey (https://exiftool.org/TagNames/Canon.html)\n\n")

	writeCanonLensType(&out, lens)
	writeCanonModelIDs(&out, models)
	ioutil.WriteFile(fileName, []byte(out), 0644)
	fmt.Printf("Generated sucessfully: %s\n", fileName)
	//fmt.Print(string(dat))
}

func writeCanonLensType(data *string, lens map[string][]string) {
	*data += fmt.Sprintln("// CanonLensType Values")
	*data += fmt.Sprintln("var canonLensTypeValues = map[int]CanonLensType{")
	for key, val := range lens {
		*data += fmt.Sprintf("\t%s: \tCanonLensType{", key)
		for _, item := range val {
			*data += fmt.Sprintf("\"%s\",", item)
		}
		*data += fmt.Sprintf("},\n")
	}
	*data += fmt.Sprintln("}\n")
}

func writeCanonModelIDs(data *string, model map[string][]string) {
	*data += fmt.Sprintln("// Canon ModelID Values")
	*data += fmt.Sprintln("var canonModelIDValues = map[uint32]models.CameraModel{")
	for key, val := range model {
		*data += fmt.Sprintf("\t%s: \tmodels.CameraModel(\"%s\"),\n", key, val[0])
	}
	*data += fmt.Sprintln("}\n")
}

func extractPerlVariable(data string, key string) string {
	// Identify variable
	key = "\n%" + key
	zp := regexp.MustCompile(key)
	a := zp.Split(data, -1)
	// Identify end of variable
	zp = regexp.MustCompile(`\n\)\;`)
	b := zp.Split(a[1], -1)
	return b[0]
}

func ExtractCanonLensTypes(data string) map[string][]string {
	i := extractPerlVariable(data, "canonLensTypes")
	// Separate each item
	zp := regexp.MustCompile(`\n([\s]+)(([0-9]+)|(-[0-9]))`)
	item := zp.FindAllString(i, -1)
	res := zp.Split(i, -1)
	list := make(map[string][]string)
	// Remove Comments
	commentRE := regexp.MustCompile(`\#`)
	qre := regexp.MustCompile(`\'([A-Za-z0-9\/\-\.\s\+\\[\])\(\|]+)\'`)
	sum := 0
	for i := 0; i < len(item); i++ {
		// Key
		key := spaceStringsBuilder(item[i])
		// Remove comments
		str := commentRE.Split(res[i+1], -1)
		value := qre.FindString(str[0])
		// Remove quotations
		value = strings.Replace(value, "'", "", -1)
		list[key] = append(list[key], value)
		sum += i
	}
	return list
}

func ExtractCanonModelIDs(data string) map[string][]string {
	i := extractPerlVariable(data, "canonModelID")
	// Separate each item
	zp := regexp.MustCompile(`\n([\s]+)(0x)([0-9]+)`)
	item := zp.FindAllString(i, -1)
	res := zp.Split(i, -1)
	list := make(map[string][]string)
	// Remove Comments
	commentRE := regexp.MustCompile(`\#`)
	qre := regexp.MustCompile(`\'([A-Za-z0-9\/\-\.\s\+\\[\])\(\|]+)\'`)
	sum := 0
	for i := 0; i < len(item); i++ {
		// Key
		key := spaceStringsBuilder(item[i])
		// Remove comments
		str := commentRE.Split(res[i+1], -1)
		value := qre.FindString(str[0])
		// Remove quotations
		value = strings.Replace(value, "'", "", -1)
		list[key] = append(list[key], value)
		sum += i
	}
	return list
}

func spaceStringsBuilder(str string) string {
	var b strings.Builder
	b.Grow(len(str))
	for _, ch := range str {
		if !unicode.IsSpace(ch) {
			b.WriteRune(ch)
		}
	}
	return b.String()
}
